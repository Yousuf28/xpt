[{"name":"app.R","content":"##  This code is for creating shiny app that can read and write xpt file.\r\n## xpt file also can be exported as xlsx (Excel) and csv file\r\n\r\n## -----------------------------------------------------------------------------\r\n##   Date                     Programmer\r\n## ----------   --------------------------------------------------------------\r\n##   Oct-05-2023    Md Yousuf Ali (md.ali@fda.hhs.gov)\r\n\r\n# required R packages\r\n# library(shiny)\r\n# library(DT)\r\n# library(haven)\r\n# library(writexl)\r\n# library(readxl)\r\n# library(fs)\r\n\r\nsource('create_xlsx.R')\r\ndownloadButton <- function(...) {\r\n  tag <- shiny::downloadButton(...)\r\n  tag$attribs$download <- NULL\r\n  tag\r\n}\r\n# Define UI for data upload app ----\r\nui <- shiny::fluidPage(\r\n  shiny::titlePanel('xptView'),\r\n\r\n  shiny::sidebarLayout(\r\n    shiny::sidebarPanel(width = 2,\r\n\r\n    # file upload\r\n      shiny::fileInput('file1', 'Choose xpt/xlsx file',\r\n        accept = c('.xpt', '.xlsx')),\r\n      shiny::tags$hr(style = 'border-top: 1px dashed black'),\r\n      # add row\r\n      shiny::actionButton('add_row', label = 'Add Row'),\r\n      shiny::tags$hr(style = 'border-top: 1px dashed black'),\r\n      # delete row\r\n      shiny::actionButton('delete_row', label = 'Delete Row'),\r\n      shiny::tags$hr(style = 'border-top: 1px dashed black'),\r\n      # download as xpt\r\n      downloadButton('down_xpt', 'Download file as xpt'),\r\n      shiny::tags$hr(style = 'border-top: 1px dashed black'),\r\n      # download as xlsx\r\n      downloadButton('down_xls', 'Download as excel file'),\r\n      shiny::tags$hr(style = 'border-top: 1px dashed black'),\r\n      # download as csv\r\n      downloadButton('down_csv', 'Download file as csv')\r\n\r\n    ),\r\n# table\r\n    shiny::mainPanel(\r\n      DT::DTOutput('contents')\r\n    )))\r\n\r\n\r\n# Define server logic to read selected file ----\r\nserver <- function(input, output) {\r\n  v <- shiny::reactiveVal()\r\n  shiny::observeEvent(input$file1,{\r\n    shiny::req(input$file1)\r\n    ext <- basename(input$file1$datapath)\r\n    if(grepl('xpt', ext, ignore.case = T)){\r\n      tab <- haven::read_xpt(input$file1$datapath)\r\n      v(tab)\r\n    } else{\r\n      tab <- get_xlsx(input$file1$datapath)\r\n      v(tab)\r\n    }\r\n  })\r\n  # render tabel\r\n  output$contents <- DT::renderDT({\r\n    shiny::req(input$file1)\r\n    DT::datatable(v(),\r\n      ## selection = 'single',\r\n      ## options = list(dom = 't'),\r\n      editable = T)\r\n  })\r\n  # add row , by default add last row to the begining of table\r\n  shiny::observeEvent(input$add_row,{\r\n    df <- v()\r\n    nr <- df[nrow(df), ]\r\n    t <- rbind(nr,df)\r\n    v(t)\r\n  })\r\n  ## selected row will be deleted. if no row seletecd, no row deleted\r\n  shiny::observeEvent(input$delete_row, {\r\n    t  <- v()\r\n    if (!is.null(input$contents_rows_selected)) {\r\n      t <- t[-as.numeric(input$contents_rows_selected),]\r\n    }\r\n    v(t)\r\n  })\r\n  # update cell value\r\n  shiny::observeEvent(input$contents_cell_edit, {\r\n    info <- input$contents_cell_edit\r\n    edit_row <-  info$row\r\n    edit_col <-  info$col\r\n    edit_value <-  info$value\r\n    t  <-  v()\r\n    t[edit_row,edit_col] <- edit_value\r\n    v(t)\r\n})\r\n# get file name so it can be use in download section\r\n  get_file_name <- shiny::eventReactive(input$file1, {\r\n\r\n    ext <- basename(input$file1$datapath)\r\n    if(grepl('xpt', ext, ignore.case= TRUE)) {\r\n      file_name <- strsplit(input$file1$name, '.xpt')[[1]]\r\n    } else {\r\n      file_name <- strsplit(input$file1$name, '.xlsx')[[1]]\r\n    }\r\n    ## filename <- paste0(file_name, \".xpt\")\r\n    file_name\r\n\r\n\r\n  })\r\n  # download file as xpt\r\n  output$down_xpt <- shiny::downloadHandler(\r\n    filename = function() {\r\n      file_name <- get_file_name()\r\n      file_name <- paste0(file_name, '.xpt')\r\n                              },\r\n    content = function(file) {\r\n      df <- v()\r\n      domain <- get_file_name()\r\n      temp_dir <- tempdir()\r\n      path <- fs::path(temp_dir, paste0(domain, '.xpt'))\r\n      haven::write_xpt(data = df, path=path, version = 5)\r\n      fs::file_copy(path, file)\r\n    }\r\n  )\r\n\r\n  # download csv\r\n  output$down_csv <- shiny::downloadHandler(\r\n    filename = function() {\r\n      file_name <- get_file_name()\r\n      file_name <- paste0(file_name, '.csv')\r\n    },\r\n    content = function(file) {\r\n      df <- v()\r\n      write.csv(df, file=file, quote= FALSE, row.names=FALSE)\r\n    }\r\n  )\r\n\r\n  # download xlsx (xcel file)\r\n  output$down_xls  <- shiny::downloadHandler(\r\n    filename = function() {\r\n      file_name <- get_file_name()\r\n      paste0(file_name, '.xlsx')\r\n    },\r\n    content = function(file) {\r\n      df <- v()\r\n      var_meta <- create_xlsx(df)\r\n      col <- dim(df)[2]\r\n      var_n <- dim(df)[1]\r\n      dataset_name <- toupper(get_file_name())\r\n      df_meta <- data.frame(Dataset=c(dataset_name),\r\n        Label=c(NA), Variable=c(col),\r\n        Records=c(var_n))\r\n\r\n     out <- list('Dataset Metadata'=df_meta, 'Variable Metadata'= var_meta)\r\n      out[[dataset_name]] <- df\r\n      print(names(out))\r\n      writexl::write_xlsx(out, path = file)\r\n\r\n    }\r\n  )\r\n}\r\n# Create Shiny app ----\r\nshiny::shinyApp(ui, server)\r\n","type":"text"},{"name":"create_xlsx.R","content":"##  This code is for creating xlsx file\r\n\r\n## -----------------------------------------------------------------------------\r\n##   Date                     Programmer\r\n## ----------   --------------------------------------------------------------\r\n##   Dec-28-2023    Md Yousuf Ali (md.ali@fda.hhs.gov)\r\n\r\n# this function get attribute of dataframe and return attribute as dataframe\r\ncreate_xlsx <- function(df) {\r\n\r\n  df_label <- sapply(df, attr, 'label')\r\n  df_format <- sapply(df,attr, 'format.sas')\r\n\r\n\r\n  # variable names\r\n  vars <- c()\r\n  # format like $2\r\n  form_sas <- c()\r\n  fm <- df_format\r\n  for (i in 1:length(fm)){\r\n    vars <- c(vars, names(fm[i]))\r\n    if( is.null(fm[[i]])) {\r\n      format_sas <- NA\r\n    } else {\r\n      format_sas <- fm[[i]]\r\n    }\r\n    form_sas <- c(form_sas, format_sas)\r\n\r\n  }\r\n\r\n# get digit from $2\r\n  leng <- c()\r\n  # get $ or NA\r\n  form <- c()\r\n  for(i in 1:length(form_sas)) {\r\n\r\n  if(!is.na(form_sas[i])) {\r\n\r\n    dg <- unlist(strsplit(form_sas[i], '\\\\$'))[2]\r\n    dol <- unlist(strsplit(form_sas[i], ''))[1]\r\n    leng <- c(leng,dg)\r\n    form <- c(form, dol)\r\n  } else {\r\n    leng <- c(leng, '8')\r\n    form <- c(form, NA)\r\n\r\n  }\r\n  }\r\n  leng <- as.integer(leng)\r\n\r\n  type_var <- unlist(lapply(df,class))\r\n\r\n  df_fn <- data.frame(Variable = names(df_label),\r\n                      Label = df_label,\r\n                      Type = type_var,\r\n                      Length = leng,\r\n                      Format = form,\r\n                      row.names = NULL)\r\n\r\n}\r\n\r\n# example\r\n## df <- haven::read_xpt('cl.xpt')\r\n## kd <- create_xlsx(df)\r\n## kd\r\n\r\n## this function read edited/downloaded xlsx file,\r\n## it get metadata from variable metadate sheet\r\n## and add the meta data to domain dataframe\r\n\r\nget_xlsx <- function(file) {\r\n\r\n  v_meta <- readxl::read_xlsx(file, sheet = 'Variable Metadata')\r\n  vm <- gsub('character', 'text', v_meta$Type)\r\n  df_xl <- readxl::read_xlsx(file, sheet = 3, col_types = vm)\r\n  df_xl[] <- lapply(df_xl, function(x) ifelse(is.character(x) & is.na(x), \"\", x))\r\nfor (i in 1:length(v_meta$Variable)) {\r\n  attr(df_xl[[i]], 'label') <- v_meta$Label[[i]]\r\n  if(!is.na(v_meta$Format[i])) {\r\n    formSAS <- paste0(v_meta$Format[i], v_meta$Length[i])\r\n    attr(df_xl[[i]], 'format.sas') <- formSAS\r\n  ## print(formSAS)\r\n  } else {\r\n    attr(df_xl[[i]], 'format.sas') <- NULL\r\n  }\r\n}\r\n  return(df_xl)\r\n}\r\n #example\r\n## d <- get_xlsx('')\r\n## df_xl <- get_xlsx('bw_func.xlsx')\r\n## str(df_xl)\r\n","type":"text"},{"name":"test.py","content":"#!/usr/bin/env python.exe\r\n\r\nprint('hello')\r\n\r\nfor i in range(1, 5):\r\n    print(i)\r\n\r\ndef hello():\r\n    print('hello world')\r\n","type":"text"},{"name":"test_xpt.R","content":"##  This code is for testing xpt to xlsx and vice versa\r\n\r\n## History:\r\n##   -----------------------------------------------------------------------------\r\n##   Date         Programmer            Note\r\n## ----------   --------------------  ------------------------------------------\r\n##   2024-01-09    Yousuf Ali        Initial version\r\n#\r\n\r\nlibrary(haven)\r\nlibrary(readxl)\r\nlibrary(fs)\r\nsource('create_xlsx.R')\r\n\r\nhm <- 'C:/Users/Md.Ali/OneDrive - FDA/yousuf/00_github_projects/'\r\npath <- fs::path(hm, 'xpt_rshiny_live/xpt_test_r_package')\r\nbw <- fs::path(path, 'bw.xpt')\r\nhav <- haven::read_xpt(file = bw)\r\nstr(hav)\r\n\r\ntem_d <- tempdir()\r\ntem_d\r\ntemp_path <- fs::path(tem_d, 'bw.xpt')\r\ntemp_path\r\nhav_xl <- create_xlsx(hav)\r\nhav_xl\r\nxl_file_edited <- fs::path(path, 'final_test/bw_m.xlsx')\r\nxl_edited <- readxl::read_xlsx(xl_file_edited, sheet = 3)\r\n\r\nhead(xl_edited)\r\nstr(xl_edited)\r\n\r\nhaven::write_xpt(xl_e, temp_path)\r\n\r\nxl_e <- get_xlsx(file = fs::path(path, 'final_test/bw_m.xlsx'))\r\n\r\nhead(xl_e)\r\nstr(xl_e)\r\nhttpgd::hgd()\r\nhttpgd::hgd_browse()\r\nnaniar::gg_miss_var(xl_e,show_pct = T)\r\nnaniar::gg_miss_var(hav,show_pct = T)\r\n\r\nsum(hav$BWREASEX==\"\")\r\nsum(is.na(xl_e$BWREASEX))\r\n\r\nisna <- function(x) {\r\n  sum(x==\"\")\r\n## sum(is.na(x))\r\n}\r\n\r\nunlist(lapply(hav, isna))\r\nhav\r\n\r\ndt_hav <- data.table::as.data.table(hav)\r\ndt_hav[is.na(BWSTRESN)]\r\ndt_hav\r\n\r\ntable(hav$BWSTRESN)\r\nstr(xl_e$BWSTRESN)\r\nfor (i in colnames(hav)){\r\n  print(all.equal(hav[[i]], xl_e[[i]]))\r\n}\r\n\r\n\r\nall.equal(hav$BWSTRESN, xl_e$BWSTRESN)\r\n\r\nsapply(hav, class)\r\n\r\nall.equal(hav,xl_e)\r\ncolnames(hav)\r\n\r\nunlist(sapply(hav, attr,'format.sas'))\r\nunlist(sapply(xl_e, attr,'format.sas'))\r\n\r\nf_path <- fs::path(path, 'final_test/bw_t.xlsx')\r\nwritexl::write_xlsx(xl_e, path = f_path)\r\n\r\n\r\ntest_data <- data.frame(A=c(1,2,3), B= c('A', NA, ''),\r\n                        C=c(TRUE, FALSE, TRUE),\r\n                        D=c(1, NA, 3)\r\n                        )\r\ntest_data[]\r\n\r\nf_path <- fs::path(path, 'final_test/test_data.xlsx')\r\nwritexl::write_xlsx(test_data, path = f_path)\r\n\r\nhaven::write_xpt(test_data, path = fs::path(path, 'final_test/tk.xpt'))\r\ntet <- haven::read_xpt(file = fs::path(path, 'final_test/tk.xpt'))\r\ntest_data\r\ntet\r\n## # Create a sample dataframe\r\n## df <- data.frame(\r\n##   col1 = c(\"A\", \"B\", NA, \"D\"),\r\n##   col2 = c(1, 2, NA, 4),\r\n##   col3 = c(NA, \"X\", \"Y\", NA),\r\n##   stringsAsFactors = FALSE\r\n## )\r\n## df\r\n## # Replace NA values with empty string in character columns\r\n## df[] <- lapply(df, function(x) ifelse(is.character(x) & is.na(x), \"\", x))\r\n\r\n## # Print the modified dataframe\r\n## df\r\nout <- list('ll'=c(1,2,3), kk = c('a','b','c'))\r\nout\r\nii <- 'jj'\r\nout[[ii]] <- c(1,2,3)\r\nout\r\nnames(out)\r\n","type":"text"}]
